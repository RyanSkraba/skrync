package com.skraba.skrync

import com.skraba.docoptcli.DocoptCliGoSpec
import org.scalatest.OptionValues._

import scala.reflect.io._

/** Unit tests for [[SkryncGo]] using a large generated source directory. */
class ScenarioLargeFilesSpec extends DocoptCliGoSpec(SkryncGo) {

  /** Temporary directory root for all tests. */
  val Large: ScenarioLargeFiles = new ScenarioLargeFiles(
    Directory.makeTemp(getClass.getSimpleName),
    deleteRootOnCleanup = true
  )

  override protected def afterAll(): Unit = Large.cleanup()

  describe("Working with digests and files") {

    it("calculates digests correctly") {
      // The large file.
      Digests.getSha1(Large.bigFile) shouldBe Large.bigFileDigest

      Digests.getSha1(Large.src / File("3Z0EP1uW/4SIebeyBk/Edna6/0n90T06rcb.bin")) shouldBe
        Digests.fromHex("ef7035c4aec006dc7d0c9655912b021c11d51a30")

      Digests.getSha1(Large.src / File("3Z0EP1uW/4SIebeyBk/Edna6/nvmVfF.txt")) shouldBe
        Digests.fromHex("ff5cfa665f608d53024bdce9520d5abbe78ef27f")

    }

    it("generates a SkryncDir with directory attributes and digest.") {

      // Fetch an undigested SkryncDir from the large scenario.
      val dirWithoutSha1: SkryncDir = withConsoleMatch {
        val w = new PrintDigestProgress(Console.out)
        SkryncDir.scan(Large.src, digest = false, w)
      } { case (dir: SkryncDir, stdout, stderr) =>
        // Ensure that all of the directories and files have been counted.
        stdout.groupBy(c => c).view.mapValues(c => c.length).toMap shouldBe Map(
          '[' -> 798,
          '!' -> 1000,
          ']' -> 798
        )
        stderr shouldBe ""

        dir.path.name shouldBe "large"
        // creation uses the modification time and access is not affected by reading files.
        // dir.root.creation shouldBe 2000L
        // dir.root.access shouldBe 1000L
        // dir.root.modification shouldBe 2000L
        dir.path.size shouldBe 229520625L
        dir.path.digest shouldBe None
        dir.deepFileCount shouldBe 1000
        dir.dirs should have size 9
        dir.files should have size 1

        // continue testing on the dir
        dir
      }

      val fileWithoutSha1 = dirWithoutSha1.files.head
      fileWithoutSha1.name shouldBe Large.bigFile.name
      // creation uses the modification time and access is based on the current time.
      fileWithoutSha1.creation shouldBe 11000L
      fileWithoutSha1.modification shouldBe 11000L
      fileWithoutSha1.size shouldBe Int.MaxValue / 10
      fileWithoutSha1.digest shouldBe None

      // Add digests
      val dirWithSha1: SkryncDir = withConsoleMatch {
        val w = new PrintDigestProgress(Console.out)
        dirWithoutSha1.digest(Large.src, w)
      } { case (dir: SkryncDir, stdout, stderr) =>
        // Ensure that all of the directories and files have been counted.
        // Ensure that all of the directories and files have been counted.
        stdout.groupBy(c => c).view.mapValues(c => c.length).toMap shouldBe Map(
          '{' -> 798,
          '<' -> 1000,
          '.' -> 1204,
          '>' -> 1000,
          '}' -> 798
        )
        stderr shouldBe ""

        // continue testing on the dir
        dir
      }

      dirWithSha1.files should have size 1
      val fileWithSha1 = dirWithSha1.files.head
      Digests.toHex(fileWithSha1.digest.get) shouldBe Digests.toHex(Large.bigFileDigest)
      fileWithSha1 shouldBe fileWithoutSha1.copy(digest = Some(Large.bigFileDigest))

      Digests.toHex(dirWithSha1.path.digest.get) shouldBe Digests.toHex(Large.dirDigest)

      // Check flattening the directory.
      val paths = dirWithSha1.flattenPaths(Path("flatten"))
      paths should have size 1000
      paths should contain(Path(s"flatten/${Large.bigFile.name}") -> fileWithSha1)
    }

    describe("running the digest command") {
      it("generates a file when a destination is explicitly specified.") {
        // Run the application and check the output files.
        val dstDir: Directory = Large.root.resolve("dstDigest").toDirectory
        dstDir.createDirectory()
        withGoMatching("digest", "--srcDir", Large.src, "--dstDigest", dstDir / File("output.gz")) {
          case (stdout, stderr) =>
            stdout should have size 7396
            stderr shouldBe ""
        }

        // One file is created.
        val dst: Seq[Path] = dstDir.list.toSeq
        dst should have size 1

        // It should have an autogenerated name.
        val dstDigestFile = dst.headOption.value.toFile
        dstDigestFile.name shouldBe "output.gz"

        // The contents of the file should be readable.
        val dstRoot = Json.read(dstDigestFile)
        val expected = SkryncDir.scan(Large.src, digest = true).copyWithoutTimes()
        dstRoot.info.copy(path = dstRoot.info.path.copy(name = "large")) shouldBe expected
      }
    }
  }

  describe("Comparing two digests") {

    val dstDir: Directory = Large.root.resolve("dstCompare").toDirectory
    dstDir.createDirectory()

    // Create a digests on the input.
    withGoMatching("digest", "--srcDir", Large.src, "--dstDigest", dstDir / File("compare.gz")) {
      case (stdout, stderr) =>
        stdout should have size 7396
        stderr shouldBe ""
    }

    describe("compare running the compare command") {
      it("finds no differences when run on digests created on the same directory.") {
        withGoMatching("digest", "--srcDir", Large.src, "--dstDigest", dstDir / File("compare2.gz")) {
          case (stdout, stderr) =>
            stdout should have size 7396
            stderr shouldBe ""
        }

        // Ignore the time the backup was created.
        val root = Json.read(dstDir / File("compare.gz")).copy(created = -1)
        val root2 = Json.read(dstDir / File("compare2.gz")).copy(created = -1)
        root shouldBe root2

        withGo("compare", "--srcDigest", dstDir / File("compare.gz"), "--dstDigest", dstDir / File("compare2.gz"))
      }
    }
  }
}
